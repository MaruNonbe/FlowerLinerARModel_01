<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>AR Train WebAR</title>

  <!-- ç”»é¢ã‚µã‚¤ã‚ºã«ãƒ•ã‚£ãƒƒãƒˆã•ã›ã‚‹ãŸã‚ã® viewport è¨­å®š -->
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"
  />

  <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.150.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js/aframe/build/aframe-ar.js"></script>

  <style>
    /* â˜… ã“ã“ã‚’ã‚·ãƒ³ãƒ—ãƒ«ã«ï¼šA-Frame / AR.js ã«ä»»ã›ã¤ã¤å…¨ç”»é¢ã«ã™ã‚‹  */
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #000;
    }

    /* ã‚·ãƒ¼ãƒ³ã‚’ç”»é¢å…¨ä½“ã«åºƒã’ã‚‹ï¼ˆposition:fixed ã¯ä½¿ã‚ãªã„ï¼‰ */
    a-scene {
      width: 100%;
      height: 100vh;   /* ç”»é¢ã®é«˜ã•ã´ã£ãŸã‚Š */
    }

    #ui {
      position: fixed;
      bottom: env(safe-area-inset-bottom, 10px);
      left: 0;
      width: 100%;
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 5px;
      z-index: 999;
      pointer-events: auto;
    }

    .btn {
      min-width: 48px;
      text-align: center;
      font-size: 14px;
      padding: 6px 10px;
      background: rgba(255, 255, 255, 0.9);
      border: 1px solid #333;
      border-radius: 4px;
      cursor: pointer;
      user-select: none;
    }
  </style>
</head>
<body>

  <!-- embedded + arjs ã®åŸºæœ¬å½¢ã ã‘ã«æˆ»ã™ -->
  <a-scene
    embedded
    arjs="sourceType: webcam; debugUIEnabled: false;"
    vr-mode-ui="enabled: false"
  >
    <a-marker-camera preset="hiro">
      <a-entity id="train"
                gltf-model="models/AR-Train_Nagai.glb"
                position="0 0 -1"
                rotation="0 0 0"
                scale="0.5 0.5 0.5">
      </a-entity>
    </a-marker-camera>
  </a-scene>

  <div id="ui">
    <div class="btn" id="btn-forward">â†‘</div>
    <div class="btn" id="btn-backward">â†“</div>
    <div class="btn" id="btn-left">â†</div>
    <div class="btn" id="btn-right">â†’</div>
    <div class="btn" id="btn-curve-left">â¤ºå·¦ã‚«ãƒ¼ãƒ–</div>
    <div class="btn" id="btn-curve-right">å³ã‚«ãƒ¼ãƒ–â¤»</div>
    <div class="btn" id="btn-up">â¬†ï¸</div>
    <div class="btn" id="btn-down">â¬‡ï¸</div>
    <div class="btn" id="btn-face">é¡”å†™çœŸè¨­å®š</div>
    <div class="btn" id="btn-face-rotate-y">ğŸ”„Y</div>
    <div class="btn" id="btn-face-rotate-x">ğŸ”„X</div>
    <div class="btn" id="btn-face-x-plus">é¡”Xï¼‹</div>
    <div class="btn" id="btn-face-x-minus">é¡”Xï¼</div>
    <div class="btn" id="btn-face-y-plus">é¡”Yï¼‹</div>
    <div class="btn" id="btn-face-y-minus">é¡”Yï¼</div>
    <div class="btn" id="btn-zoom-in">ï¼‹</div>
    <div class="btn" id="btn-zoom-out">ï¼</div>
    <div class="btn" id="btn-capture">ğŸ“¸</div>
    <div class="btn" id="btn-record">ğŸ¥</div>
    <div class="btn" id="btn-share">ğŸ“¤</div>
  </div>

  <script>
    const train = document.querySelector('#train');
    let facePlate = null; // ãƒ¢ãƒ‡ãƒ«å†…ã® a_Plate ã‚’ä¿æŒ

    // å‰å¾Œãƒ»æ—‹å›ãƒ»ã‚«ãƒ¼ãƒ–ç”¨ãƒ•ãƒ©ã‚°
    let moving = {
      forward: false,
      backward: false,
      left: false,
      right: false,
      curveLeft: false,
      curveRight: false
    };

    let curveRadius = 2.0;
    let zoomLevel = 0.5; // åˆæœŸã‚¹ã‚±ãƒ¼ãƒ«ã«åˆã‚ã›ã¦å¤‰æ›´
    let recording = false, recorder, chunks = [];
    let faceRotationY = 0; // é¡”å†™çœŸã®Yè»¸å›è»¢è§’åº¦ã‚’ä¿æŒã™ã‚‹å¤‰æ•°
    let faceRotationX = 0; // é¡”å†™çœŸã®Xè»¸å›è»¢è§’åº¦ã‚’ä¿æŒã™ã‚‹å¤‰æ•°

    const MOVE_SPEED = 0.15, ROTATE_SPEED = 1.0;

    /* é•·æ‰‹æ–¹å‘ã®è‡ªå‹•åˆ¤å®šï¼ˆX or Zï¼‰ã€‚å‰é€²ã¯ -Z/-X å´ï¼ˆå¿…è¦ã«å¿œã˜ã¦ +1 ã«ï¼‰ */
    let forwardAxis = 'z';
    const FORWARD_SIGN = 1; 

    train.addEventListener('model-loaded', () => {
      const root = train.getObject3D('mesh');
      if (!root) return;

      // 1) a_Plate ã‚’å–å¾—
      facePlate = root.getObjectByName('a_Plate') || root.getObjectByProperty('name','a_Plate');

      // 2) èµ·å‹•ç›´å¾Œã«ã€Œa_Plate ã®æ­£é¢(+Z)ãŒã‚«ãƒ¡ãƒ©(-Z)ã‚’å‘ãã€ã‚ˆã†ã«åˆ—è»Šã® yaw ã‚’åˆã‚ã›ã‚‹
      if (facePlate) {
        const q = new THREE.Quaternion();
        facePlate.getWorldQuaternion(q);
        const nWorld = new THREE.Vector3(0,0,1).applyQuaternion(q);
        nWorld.y = 0; nWorld.normalize();
        const target = new THREE.Vector3(0,0,-1); // ã‚«ãƒ¡ãƒ©ã®è¦–ç·šæ–¹å‘ï¼ˆ-Zï¼‰
        const angle = Math.atan2(nWorld.x, nWorld.z) - Math.atan2(target.x, target.z);
        train.object3D.rotation.y -= angle;  // â† é‹è»¢å¸­ãŒã‚«ãƒ¡ãƒ©ã‚’å‘ãã‚ˆã†ã«è£œæ­£
      }

      // 3) é•·æ‰‹æ–¹å‘ã®æ¨å®šï¼ˆX/Z ã®é•·ã„æ–¹ï¼‰
      const box = new THREE.Box3().setFromObject(root);
      const sz = new THREE.Vector3(); box.getSize(sz);
      forwardAxis = (sz.x > sz.z) ? 'x' : 'z';
    });

    /* ãƒ­ãƒ¼ã‚«ãƒ«å‰æ–¹ãƒ™ã‚¯ãƒˆãƒ«ï¼ˆX ã¾ãŸã¯ Z ã® Â± ã‚’é¸ã¶ï¼‰ã‚’ãƒ¯ãƒ¼ãƒ«ãƒ‰ã«å¤‰æ› */
    function getForwardWorld(obj){
      const local = (forwardAxis==='x') ? new THREE.Vector3(FORWARD_SIGN,0,0)
                                        : new THREE.Vector3(0,0,FORWARD_SIGN);
      return local.applyQuaternion(obj.quaternion).normalize();
    }

    /* å‰å¾Œãƒ»å¼§ç§»å‹•ï¼ˆã‚«ãƒ¼ãƒ–å¯¾å¿œï¼‰ */
    function moveTrain() {
      const obj = train.object3D;
      const pos = obj.position;

      let dir  = moving.forward ? 1 : (moving.backward ? -1 : 0); // å‰é€²=+1, å¾Œé€²=-1
      let turn = moving.left    ? 1 : (moving.right    ? -1 : 0); // å·¦=+1, å³=-1

      // ã‚«ãƒ¼ãƒ–ãƒœã‚¿ãƒ³ãŒæŠ¼ã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ã€Œå‰é€²ï¼‹æ—‹å›ã€ã‚’å„ªå…ˆ
      if (moving.curveLeft) {
        dir = 1;
        turn = 1;
      } else if (moving.curveRight) {
        dir = 1;
        turn = -1;
      }

      if (dir !== 0 && turn !== 0) {
        const v = dir * MOVE_SPEED;
        const omega = (turn * v) / curveRadius; // å³å‰é€²â†’æ™‚è¨ˆå›ã‚Šã€å³å¾Œé€²â†’åæ™‚è¨ˆå›ã‚Š
        obj.rotation.y += omega;
        pos.addScaledVector(getForwardWorld(obj), v);
      } else if (dir !== 0) {
        pos.addScaledVector(getForwardWorld(obj), dir * MOVE_SPEED);
      } else if (turn !== 0) {
        obj.rotation.y += turn * ROTATE_SPEED * Math.PI / 180;
      }

      if (Object.values(moving).some(v => v)) requestAnimationFrame(moveTrain);
    }

    /* UI */
    function setupButton(id, key) {
      const btn = document.getElementById(id);
      btn.ontouchstart = btn.onmousedown = e => {
        moving[key] = true;
        moveTrain();
        e.preventDefault();
      };
      btn.ontouchend = btn.onmouseup = () => { moving[key] = false; };
      btn.onmouseleave = () => { moving[key] = false; };
      btn.ontouchcancel = () => { moving[key] = false; };
    }

    ['forward','backward','left','right'].forEach(id => setupButton(`btn-${id}`, id));
    setupButton('btn-curve-left', 'curveLeft');
    setupButton('btn-curve-right', 'curveRight');

    document.getElementById("btn-up").onclick   = () => train.object3D.position.y += 0.1;
    document.getElementById("btn-down").onclick = () => train.object3D.position.y -= 0.1;

    /* é¡”å†™çœŸï¼ša_Plate ã«ç›´æ¥è²¼ã‚‹ï¼ˆã‚¢ãƒ³ãƒªãƒƒãƒˆåŒ–ã€åè»¢/è‰²ç©ºé–“/Zãƒ•ã‚¡ã‚¤ãƒˆå¯¾ç­–ï¼‰ */
    document.getElementById("btn-face").onclick = () => {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = 'image/*';
      input.onchange = e => {
        const file = e.target.files[0]; if (!file) return;
        const url = URL.createObjectURL(file);

        const applyToPlate = () => {
          new THREE.TextureLoader().load(url, tex => {
            tex.flipY = false;
            tex.encoding = THREE.sRGBEncoding;
            tex.needsUpdate = true;

            if (facePlate) {
              facePlate.material.map = tex;
              facePlate.material.transparent = true;
              facePlate.material.needsUpdate = true;
              facePlate.rotation.y = faceRotationY;
              facePlate.rotation.x = faceRotationX;
            } else {
              const geo = new THREE.PlaneGeometry(1.0, 1.0);
              const mat = new THREE.MeshBasicMaterial({
                map: tex,
                transparent: true,
                side: THREE.DoubleSide,
                depthTest: false,
                depthWrite: false
              });
              const mesh = new THREE.Mesh(geo, mat);

              // ä»®ã®é‹è»¢å¸­ä½ç½®ï¼ˆå¿…è¦ã«å¿œã˜ã¦èª¿æ•´ï¼‰
              mesh.position.set(0, 1.5, 2.5);

              mesh.rotation.y = faceRotationY;
              mesh.rotation.x = faceRotationX;
              mesh.renderOrder = 10;
              train.object3D.add(mesh);
              facePlate = mesh;
            }
          });
        };

        if (train.getObject3D('mesh')) applyToPlate();
        else train.addEventListener('model-loaded', applyToPlate, { once: true });
      };
      input.click();
    };

    document.getElementById("btn-face-rotate-y").onclick = () => {
      if (facePlate) {
        faceRotationY += Math.PI / 2;
        facePlate.rotation.y = faceRotationY;
      }
    };

    document.getElementById("btn-face-rotate-x").onclick = () => {
      if (facePlate) {
        faceRotationX += Math.PI / 2;
        facePlate.rotation.x = faceRotationX;
      }
    };

    document.getElementById("btn-face-x-plus").onclick  = () => { if (facePlate) facePlate.position.x += 0.05; };
    document.getElementById("btn-face-x-minus").onclick = () => { if (facePlate) facePlate.position.x -= 0.05; };
    document.getElementById("btn-face-y-plus").onclick  = () => { if (facePlate) facePlate.position.y += 0.05; };
    document.getElementById("btn-face-y-minus").onclick = () => { if (facePlate) facePlate.position.y -= 0.05; };

    document.getElementById("btn-zoom-in").onclick  = () => {
      zoomLevel += 0.1;
      train.object3D.scale.set(zoomLevel, zoomLevel, zoomLevel);
    };
    document.getElementById("btn-zoom-out").onclick = () => {
      zoomLevel = Math.max(0.1, zoomLevel - 0.1);
      train.object3D.scale.set(zoomLevel, zoomLevel, zoomLevel);
    };

    document.getElementById("btn-capture").onclick = () => {
      const canvas = document.querySelector('canvas');
      canvas.toBlob(blob => {
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = "snapshot.png";
        a.click();
      });
    };

    document.getElementById("btn-record").onclick = () => {
      if (!recording) {
        const stream = document.querySelector('canvas').captureStream();
        recorder = new MediaRecorder(stream);
        recorder.ondataavailable = e => chunks.push(e.data);
        recorder.onstop = () => {
          const b = new Blob(chunks, { type: 'video/webm' });
          const a = document.createElement('a');
          a.href = URL.createObjectURL(b);
          a.download = "recording.webm";
          a.click();
          chunks = [];
        };
        recorder.start(); recording = true; alert("éŒ²ç”»é–‹å§‹");
      } else {
        recorder.stop(); recording = false; alert("éŒ²ç”»çµ‚äº†");
      }
    };

    document.getElementById("btn-share").onclick = () => {
      if (navigator.share) {
        navigator.share({ title: "AR Train", text: "ç§ã®é‹è»¢å£«ä½“é¨“ã‚’è¦‹ã¦ã­ï¼", url: location.href });
      } else {
        alert("ã“ã®ãƒ–ãƒ©ã‚¦ã‚¶ã¯Webã‚·ã‚§ã‚¢APIã«å¯¾å¿œã—ã¦ã„ã¾ã›ã‚“");
      }
    };
  </script>
</body>
</html>
