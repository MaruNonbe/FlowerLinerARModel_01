<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>AR Train WebAR</title>
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
  />

  <!-- A-Frame & AR.js -->
  <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js/aframe/build/aframe-ar.js"></script>
  <!-- THREE ã¯ A-Frame å†…éƒ¨ã«ã‚‚ã‚ã‚Šã¾ã™ãŒã€å¿µã®ãŸã‚å€‹åˆ¥èª­ã¿è¾¼ã¿ã—ã¦ãŠãã¾ã™ -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.150.0/build/three.min.js"></script>

  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #000;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
    }

    /* AR ç”»é¢ã‚’å¸¸ã«ãƒ•ãƒ«ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã«ã™ã‚‹ */
    a-scene {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 1;
    }

    #ui {
      position: fixed;
      bottom: 10px;
      left: 0;
      width: 100%;
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 5px;
      z-index: 10;
      pointer-events: auto;
    }

    .btn {
      min-width: 60px;
      text-align: center;
      font-size: 14px;
      padding: 6px 10px;
      background: rgba(255, 255, 255, 0.9);
      border: 1px solid #333;
      border-radius: 4px;
      cursor: pointer;
      user-select: none;
    }
  </style>
</head>

<body>

  <!-- â˜… ãƒãƒ¼ã‚«ãƒ¼ Hiro ã‚’ä½¿ã£ãŸ AR ã‚·ãƒ¼ãƒ³ï¼ˆãƒ•ãƒ«ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ï¼‰ -->
  <a-scene
    embedded
    vr-mode-ui="enabled: false"
    renderer="alpha: true; antialias: true"
    arjs="sourceType: webcam; debugUIEnabled: false;"
  >
    <!-- ãƒãƒ¼ã‚«ãƒ¼ä»˜ãã‚«ãƒ¡ãƒ©ï¼ˆHiro ãƒãƒ¼ã‚«ãƒ¼ä½¿ç”¨ï¼‰ -->
    <a-marker-camera preset="hiro">
      <!-- åˆ—è»Šãƒ¢ãƒ‡ãƒ«ï¼šã‚«ãƒ¡ãƒ©ã®å‰æ–¹ 1m ã«é…ç½® -->
      <a-entity
        id="train"
        gltf-model="models/AR-Train_Nagai.glb"
        position="0 0 -1"
        rotation="0 0 0"
        scale="0.5 0.5 0.5">
      </a-entity>
    </a-marker-camera>
  </a-scene>

  <!-- UI ãƒœã‚¿ãƒ³ç¾¤ -->
  <div id="ui">
    <div class="btn" id="btn-forward">â†‘</div>
    <div class="btn" id="btn-backward">â†“</div>
    <div class="btn" id="btn-left">â†</div>
    <div class="btn" id="btn-right">â†’</div>
    <div class="btn" id="btn-curve-right">â†ªå³ã‚«ãƒ¼ãƒ–</div>
    <div class="btn" id="btn-curve-left">â†©å·¦ã‚«ãƒ¼ãƒ–</div>

    <div class="btn" id="btn-up">â¬†ï¸</div>
    <div class="btn" id="btn-down">â¬‡ï¸</div>

    <div class="btn" id="btn-face">é¡”å†™çœŸè¨­å®š</div>
    <div class="btn" id="btn-face-rotate-y">é¡”YğŸ”„</div>
    <div class="btn" id="btn-face-rotate-x">é¡”XğŸ”„</div>
    <div class="btn" id="btn-face-x-plus">é¡”Xï¼‹</div>
    <div class="btn" id="btn-face-x-minus">é¡”Xï¼</div>
    <div class="btn" id="btn-face-y-plus">é¡”Yï¼‹</div>
    <div class="btn" id="btn-face-y-minus">é¡”Yï¼</div>

    <div class="btn" id="btn-zoom-in">ï¼‹</div>
    <div class="btn" id="btn-zoom-out">ï¼</div>

    <div class="btn" id="btn-capture">ğŸ“¸</div>
    <div class="btn" id="btn-record">ğŸ¥</div>
    <div class="btn" id="btn-share">ğŸ“¤</div>
  </div>

  <script>
    const train = document.querySelector('#train');

    // é¡”å†™çœŸã‚’è²¼ã‚‹ãŸã‚ã® Meshï¼ˆa_Plate ã‚’å„ªå…ˆï¼‰
    let facePlate = null;
    let faceRotationY = 0;
    let faceRotationX = 0;

    // å‰é€²ãƒ»å¾Œé€€ãƒ»å·¦å³ã‚«ãƒ¼ãƒ–
    const MOVE_SPEED = 0.15;      // 1ãƒ•ãƒ¬ãƒ¼ãƒ ã‚ãŸã‚Šã®ç§»å‹•å¹…
    const ROTATE_SPEED = 1.0;     // ãã®å ´æ—‹å›ï¼ˆdeg/frameï¼‰
    const curveRadius = 2.0;      // ã‚«ãƒ¼ãƒ–åŠå¾„ï¼ˆè¦‹ãŸç›®ç”¨ï¼‰

    let forwardAxis = 'z';
    const FORWARD_SIGN = 1;
    let zoomLevel = 0.5;

    let moving = {
      forward: false,
      backward: false,
      left: false,
      right: false
    };

    let recording = false;
    let recorder = null;
    let chunks = [];

    // ç”»é¢ã‚µã‚¤ã‚ºã«åˆã‚ã›ã¦ a-scene ã‚’èª¿æ•´ï¼ˆå¿µã®ãŸã‚ï¼‰
    function resizeScene() {
      const sceneEl = document.querySelector('a-scene');
      if (!sceneEl) return;
      sceneEl.style.width = window.innerWidth + 'px';
      sceneEl.style.height = window.innerHeight + 'px';
    }
    window.addEventListener('resize', resizeScene);
    window.addEventListener('orientationchange', resizeScene);
    window.addEventListener('load', resizeScene);

    // ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿å®Œäº†æ™‚
    train.addEventListener('model-loaded', () => {
      const root = train.getObject3D('mesh');
      if (!root) return;

      // 1) a_Plate ã‚’å–å¾—
      facePlate =
        root.getObjectByName('a_Plate') ||
        root.getObjectByProperty('name', 'a_Plate') ||
        null;

      // 2) é•·æ‰‹æ–¹å‘ï¼ˆX/Z ã®é•·ã„æ–¹ï¼‰ã‚’æ¨å®šã—ã¦ã€å‰é€²æ–¹å‘ã«ä½¿ã†
      const box = new THREE.Box3().setFromObject(root);
      const size = new THREE.Vector3();
      box.getSize(size);
      forwardAxis = (size.x > size.z) ? 'x' : 'z';
    });

    // åˆ—è»Šãƒ­ãƒ¼ã‚«ãƒ«ã®ã€Œå‰æ–¹å‘ã€ã‚’ãƒ¯ãƒ¼ãƒ«ãƒ‰åº§æ¨™ã«å¤‰æ›
    function getForwardWorld(obj3D) {
      const local = (forwardAxis === 'x')
        ? new THREE.Vector3(FORWARD_SIGN, 0, 0)
        : new THREE.Vector3(0, 0, FORWARD_SIGN);
      return local.applyQuaternion(obj3D.quaternion).normalize();
    }

    // ç§»å‹•å‡¦ç†ï¼ˆrequestAnimationFrame ãƒ«ãƒ¼ãƒ—ï¼‰
    function moveTrain() {
      const obj = train.object3D;
      const pos = obj.position;

      const dir = moving.forward ? 1 : (moving.backward ? -1 : 0);
      const turn = moving.left ? 1 : (moving.right ? -1 : 0);

      if (dir !== 0 && turn !== 0) {
        const v = dir * MOVE_SPEED;
        const omega = (turn * v) / curveRadius;
        obj.rotation.y += omega;
        pos.addScaledVector(getForwardWorld(obj), v);
      } else if (dir !== 0) {
        pos.addScaledVector(getForwardWorld(obj), dir * MOVE_SPEED);
      } else if (turn !== 0) {
        obj.rotation.y += turn * ROTATE_SPEED * Math.PI / 180;
      }

      if (Object.values(moving).some(v => v)) {
        requestAnimationFrame(moveTrain);
      }
    }

    // ãƒœã‚¿ãƒ³é•·æŠ¼ã—ã§ç§»å‹•
    function setupButton(btnId, key) {
      const btn = document.getElementById(btnId);

      const start = (e) => {
        moving[key] = true;
        moveTrain();
        e.preventDefault();
      };
      const end = (e) => {
        moving[key] = false;
        e && e.preventDefault();
      };

      btn.addEventListener('mousedown', start);
      btn.addEventListener('touchstart', start, { passive: false });
      btn.addEventListener('mouseup', end);
      btn.addEventListener('mouseleave', end);
      btn.addEventListener('touchend', end);
      btn.addEventListener('touchcancel', end);
    }

    ['forward', 'backward', 'left', 'right'].forEach(dir => {
      setupButton(`btn-${dir}`, dir);
    });

    // å³ã‚«ãƒ¼ãƒ–ï¼å·¦ã‚«ãƒ¼ãƒ–å°‚ç”¨ãƒœã‚¿ãƒ³
    const btnCurveRight = document.getElementById('btn-curve-right');
    const btnCurveLeft  = document.getElementById('btn-curve-left');

    function setupCurveButton(btn, turnKey) {
      const start = (e) => {
        moving.forward = true;
        moving[turnKey] = true;
        moveTrain();
        e.preventDefault();
      };
      const end = (e) => {
        moving.forward = false;
        moving[turnKey] = false;
        e && e.preventDefault();
      };
      btn.addEventListener('mousedown', start);
      btn.addEventListener('touchstart', start, { passive: false });
      btn.addEventListener('mouseup', end);
      btn.addEventListener('mouseleave', end);
      btn.addEventListener('touchend', end);
      btn.addEventListener('touchcancel', end);
    }
    setupCurveButton(btnCurveRight, 'right');
    setupCurveButton(btnCurveLeft, 'left');

    // ä¸Šä¸‹ç§»å‹•
    document.getElementById('btn-up').onclick = () => {
      train.object3D.position.y += 0.1;
    };
    document.getElementById('btn-down').onclick = () => {
      train.object3D.position.y -= 0.1;
    };

    // é¡”å†™çœŸã‚’ a_Plate ã«è²¼ã‚‹
    document.getElementById('btn-face').onclick = () => {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = 'image/*';
      input.capture = 'user'; // iOS ã§ã‚«ãƒ¡ãƒ©æ’®å½±ã®ãƒ’ãƒ³ãƒˆ

      input.onchange = (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const url = URL.createObjectURL(file);

        const applyToPlate = () => {
          const loader = new THREE.TextureLoader();
          loader.load(url, (tex) => {
            tex.flipY = false;
            tex.encoding = THREE.sRGBEncoding;
            tex.needsUpdate = true;

            if (facePlate) {
              if (!Array.isArray(facePlate.material)) {
                facePlate.material.map = tex;
                facePlate.material.transparent = true;
                facePlate.material.needsUpdate = true;
              }
              facePlate.rotation.y = faceRotationY;
              facePlate.rotation.x = faceRotationX;
            } else {
              // a_Plate ãŒãªã„å ´åˆã¯ã€é‹è»¢å¸­ä»˜è¿‘ã« Plane ã‚’è¿½åŠ 
              const geo = new THREE.PlaneGeometry(1.0, 1.0);
              const mat = new THREE.MeshBasicMaterial({
                map: tex,
                transparent: true,
                side: THREE.DoubleSide,
                depthTest: false,
                depthWrite: false
              });
              const mesh = new THREE.Mesh(geo, mat);
              mesh.position.set(0.5, 2.8, -0.3); // ä»®ä½ç½®
              mesh.rotation.y = faceRotationY;
              mesh.rotation.x = faceRotationX;
              mesh.renderOrder = 10;
              train.object3D.add(mesh);
              facePlate = mesh;
            }
          });
        };

        // ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿æ¸ˆã¿ãªã‚‰ã™ãé©ç”¨
        if (train.getObject3D('mesh')) {
          applyToPlate();
        } else {
          train.addEventListener('model-loaded', applyToPlate, { once: true });
        }
      };

      input.click();
    };

    // é¡”ã®å›è»¢ãƒ»ä½ç½®èª¿æ•´
    document.getElementById('btn-face-rotate-y').onclick = () => {
      if (facePlate) {
        faceRotationY += Math.PI / 2;
        facePlate.rotation.y = faceRotationY;
      }
    };
    document.getElementById('btn-face-rotate-x').onclick = () => {
      if (facePlate) {
        faceRotationX += Math.PI / 2;
        facePlate.rotation.x = faceRotationX;
      }
    };
    document.getElementById('btn-face-x-plus').onclick = () => {
      if (facePlate) facePlate.position.x += 0.05;
    };
    document.getElementById('btn-face-x-minus').onclick = () => {
      if (facePlate) facePlate.position.x -= 0.05;
    };
    document.getElementById('btn-face-y-plus').onclick = () => {
      if (facePlate) facePlate.position.y += 0.05;
    };
    document.getElementById('btn-face-y-minus').onclick = () => {
      if (facePlate) facePlate.position.y -= 0.05;
    };

    // ã‚ºãƒ¼ãƒ ï¼ˆåˆ—è»Šã®ã‚¹ã‚±ãƒ¼ãƒ«ï¼‰
    document.getElementById('btn-zoom-in').onclick = () => {
      zoomLevel += 0.1;
      train.object3D.scale.set(zoomLevel, zoomLevel, zoomLevel);
    };
    document.getElementById('btn-zoom-out').onclick = () => {
      zoomLevel = Math.max(0.1, zoomLevel - 0.1);
      train.object3D.scale.set(zoomLevel, zoomLevel, zoomLevel);
    };

    // å†™çœŸæ’®å½±
    document.getElementById('btn-capture').onclick = () => {
      const canvas = document.querySelector('canvas');
      if (!canvas) return;
      canvas.toBlob((blob) => {
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = 'snapshot.png';
        a.click();
      });
    };

    // éŒ²ç”»
    document.getElementById('btn-record').onclick = () => {
      const canvas = document.querySelector('canvas');
      if (!canvas) return;

      if (!recording) {
        const stream = canvas.captureStream();
        recorder = new MediaRecorder(stream);
        recorder.ondataavailable = (e) => chunks.push(e.data);
        recorder.onstop = () => {
          const blob = new Blob(chunks, { type: 'video/webm' });
          const a = document.createElement('a');
          a.href = URL.createObjectURL(blob);
          a.download = 'recording.webm';
          a.click();
          chunks = [];
        };
        recorder.start();
        recording = true;
        alert('éŒ²ç”»é–‹å§‹');
      } else {
        recorder.stop();
        recording = false;
        alert('éŒ²ç”»çµ‚äº†');
      }
    };

    // å…±æœ‰
    document.getElementById('btn-share').onclick = () => {
      if (navigator.share) {
        navigator.share({
          title: 'AR Train',
          text: 'ARã§é‹è»¢å£«ä½“é¨“ã‚’ã—ã¦ã¿ã¾ã—ãŸï¼',
          url: location.href
        }).catch(() => {});
      } else {
        alert('ã“ã®ãƒ–ãƒ©ã‚¦ã‚¶ã¯ Web ã‚·ã‚§ã‚¢ API ã«å¯¾å¿œã—ã¦ã„ã¾ã›ã‚“ã€‚');
      }
    };
  </script>
</body>
</html>
