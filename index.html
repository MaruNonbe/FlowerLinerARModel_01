<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>AR Train WebAR</title>

  <!-- A-Frame & AR.js -->
  <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.150.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js/aframe/build/aframe-ar.js"></script>

  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      height: 100%;
      background: #000;  /* äºˆå‚™ã®èƒŒæ™¯ï¼ˆã‚«ãƒ¡ãƒ©ãŒæ˜ ã‚‰ãªã„ã¨ãç”¨ï¼‰ */
    }

    /* A-Frame / AR.js ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’ç«¯æœ«ã„ã£ã±ã„ã«åºƒã’ã‚‹ */
    a-scene {
      position: fixed !important;
      top: 0;
      left: 0;
      width: 100% !important;
      height: 100% !important;
    }
    a-scene canvas {
      width: 100% !important;
      height: 100% !important;
      display: block;
    }

    /* UI ãƒœã‚¿ãƒ³ */
    #ui {
      position: fixed;
      bottom: 10px;
      left: 0;
      width: 100%;
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 5px;
      z-index: 9999;
    }
    .btn {
      min-width: 64px;
      text-align: center;
      font-size: 14px;
      padding: 6px 10px;
      background: rgba(255, 255, 255, 0.95);
      border: 1px solid #333;
      border-radius: 4px;
      cursor: pointer;
      user-select: none;
    }

    /* çŠ¶æ…‹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸è¡¨ç¤º */
    #status {
      position: fixed;
      top: 8px;
      left: 8px;
      right: 8px;
      padding: 4px 8px;
      font-size: 14px;
      color: #0f0;
      background: rgba(0,0,0,0.4);
      z-index: 9999;
    }
  </style>
</head>
<body>

<div id="status">ã‚«ãƒ¡ãƒ©èµ·å‹•ä¸­...</div>

<!-- â˜… ã‚«ãƒ¡ãƒ©èƒŒæ™¯ã¤ã AR.js ã‚·ãƒ¼ãƒ³ â˜… -->
<a-scene
  vr-mode-ui="enabled: false"
  embedded
  renderer="precision: mediump; antialias: true; alpha: true;"
  arjs="trackingMethod: best; sourceType: webcam; debugUIEnabled: false;"
>
  <!-- Hiro ãƒãƒ¼ã‚«ãƒ¼ã‚’ä½¿ã† -->
  <a-marker-camera preset="hiro">
    <a-entity id="train"
              gltf-model="models/AR-Train_Nagai.glb"
              position="0 0 -1"
              rotation="0 0 0"
              scale="0.5 0.5 0.5">
    </a-entity>
  </a-marker-camera>
</a-scene>

<!-- æ“ä½œç”¨ UI -->
<div id="ui">
  <div class="btn" id="btn-forward">â†‘</div>
  <div class="btn" id="btn-backward">â†“</div>
  <div class="btn" id="btn-left">â†</div>
  <div class="btn" id="btn-right">â†’</div>
  <div class="btn" id="btn-curve-right">â†ºå³ã‚«ãƒ¼ãƒ–</div>
  <div class="btn" id="btn-curve-left">â†»å·¦ã‚«ãƒ¼ãƒ–</div>

  <div class="btn" id="btn-up">â¬†ï¸</div>
  <div class="btn" id="btn-down">â¬‡ï¸</div>

  <div class="btn" id="btn-face">é¡”å†™çœŸè¨­å®š</div>
  <div class="btn" id="btn-face-rotate-y">é¡”YğŸ”„</div>
  <div class="btn" id="btn-face-rotate-x">é¡”XğŸ”„</div>
  <div class="btn" id="btn-face-x-plus">é¡”Xï¼‹</div>
  <div class="btn" id="btn-face-x-minus">é¡”Xï¼</div>
  <div class="btn" id="btn-face-y-plus">é¡”Yï¼‹</div>
  <div class="btn" id="btn-face-y-minus">é¡”Yï¼</div>

  <div class="btn" id="btn-zoom-in">ï¼‹</div>
  <div class="btn" id="btn-zoom-out">ï¼</div>

  <div class="btn" id="btn-capture">ğŸ“¸</div>
  <div class="btn" id="btn-record">ğŸ¥</div>
  <div class="btn" id="btn-share">ğŸ“¤</div>
</div>

<script>
const statusEl   = document.getElementById('status');
const train      = document.querySelector('#train');
let   facePlate  = null;   // ãƒ¢ãƒ‡ãƒ«å†…ã® a_Plateï¼ˆã¾ãŸã¯ä»£æ›¿å¹³é¢ï¼‰
let   forwardAxis = 'z';
const FORWARD_SIGN = 1;

let moving = {
  forward: false,
  backward: false,
  left: false,
  right: false,
  curveRight: false,
  curveLeft: false
};

let curveRadius = 2.0;
let zoomLevel   = 0.5;
let recording   = false, recorder, chunks = [];
let faceRotationY = 0;
let faceRotationX = 0;

const MOVE_SPEED   = 0.15;
const ROTATE_SPEED = 1.0;

/* ========== ã‚«ãƒ¡ãƒ©å–å¾—ãƒã‚§ãƒƒã‚¯ï¼ˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ç”¨ã€‚AR.js ã¨ã¯åˆ¥ï¼‰ ========== */
if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
  navigator.mediaDevices.getUserMedia({ video: true })
    .then(stream => {
      stream.getTracks().forEach(t => t.stop());
      statusEl.textContent = 'ã‚«ãƒ¡ãƒ©å–å¾—OKã€‚Hiroãƒãƒ¼ã‚«ãƒ¼ã‚’æ˜ ã—ã¦ãã ã•ã„ã€‚';
    })
    .catch(err => {
      console.warn(err);
      statusEl.textContent = 'ã‚«ãƒ¡ãƒ©å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸã€‚è¨­å®šã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚';
      statusEl.style.color = '#f66';
    });
} else {
  statusEl.textContent = 'ã“ã®ç«¯æœ«ã¯ã‚«ãƒ¡ãƒ©APIã«å¯¾å¿œã—ã¦ã„ã¾ã›ã‚“ã€‚';
  statusEl.style.color = '#f66';
}

/* ========== ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿å¾Œã®å‡¦ç†ï¼ˆå‘ãåˆ¤å®šãƒ»a_Plateå–å¾—ï¼‰ ========== */
train.addEventListener('model-loaded', () => {
  const root = train.getObject3D('mesh');
  if (!root) return;

  // a_Plate ã‚’å–å¾—ï¼ˆãªã‘ã‚Œã° null ã®ã¾ã¾ï¼‰
  facePlate = root.getObjectByName('a_Plate') ||
              root.getObjectByProperty('name', 'a_Plate');

  // åˆ—è»Šã®é•·æ‰‹æ–¹å‘ã‚’æ¨å®šï¼ˆX or Zï¼‰
  const box = new THREE.Box3().setFromObject(root);
  const size = new THREE.Vector3();
  box.getSize(size);
  forwardAxis = (size.x > size.z) ? 'x' : 'z';

  // ã‚«ãƒ¡ãƒ©ã‹ã‚‰ 2mãƒ»é«˜ã•1.5mã®ä½ç½®ã§ã€åˆ—è»Šå‰é¢ã‚’è¦‹ã‚‹ã‚ˆã†ã«ã‚¹ã‚¿ãƒ¼ãƒˆ
  const obj = train.object3D;
  obj.position.set(0, 0, -2);   // ã‚«ãƒ¡ãƒ©å‰æ–¹ 2m
  obj.rotation.set(0, 0, 0);    // æ­£é¢ã‚’ã‚«ãƒ¡ãƒ©ã«å‘ã‘ã‚‹ï¼ˆãƒ¢ãƒ‡ãƒ«ã®å‘ãã«å¿œã˜ã¦èª¿æ•´å¯ï¼‰

  statusEl.textContent = 'Hiroãƒãƒ¼ã‚«ãƒ¼ã‚’ã‚«ãƒ¡ãƒ©ã«æ˜ ã—ã¦ãã ã•ã„ã€‚';
});

/* ========== å‰æ–¹ãƒ™ã‚¯ãƒˆãƒ«ï¼ˆãƒ­ãƒ¼ã‚«ãƒ«â†’ãƒ¯ãƒ¼ãƒ«ãƒ‰ï¼‰ ========== */
function getForwardWorld(obj) {
  const local = (forwardAxis === 'x')
    ? new THREE.Vector3(FORWARD_SIGN, 0, 0)
    : new THREE.Vector3(0, 0, FORWARD_SIGN);
  return local.applyQuaternion(obj.quaternion).normalize();
}

/* ========== ç§»å‹•å‡¦ç† ========== */
function moveTrain() {
  const obj = train.object3D;
  const pos = obj.position;

  const dir = moving.forward ? 1 : (moving.backward ? -1 : 0);
  const turn = moving.left ? 1 : (moving.right ? -1 : 0);
  const curveRight = moving.curveRight;
  const curveLeft  = moving.curveLeft;

  if (dir !== 0 && (turn !== 0 || curveRight || curveLeft)) {
    const v = dir * MOVE_SPEED;
    const turnSign = curveRight ? -1 : (curveLeft ? 1 : turn);
    const omega = (turnSign * v) / curveRadius;
    obj.rotation.y += omega;
    pos.addScaledVector(getForwardWorld(obj), v);
  } else if (dir !== 0) {
    pos.addScaledVector(getForwardWorld(obj), dir * MOVE_SPEED);
  } else if (turn !== 0) {
    obj.rotation.y += turn * ROTATE_SPEED * Math.PI / 180;
  }

  if (Object.values(moving).some(v => v)) {
    requestAnimationFrame(moveTrain);
  }
}

/* ========== ãƒœã‚¿ãƒ³è¨­å®š ========== */
function setupButton(id, key) {
  const btn = document.getElementById(id);
  if (!btn) return;
  btn.ontouchstart = btn.onmousedown = e => {
    moving[key] = true;
    moveTrain();
    e.preventDefault();
  };
  btn.ontouchend = btn.onmouseup = () => { moving[key] = false; };
  btn.onmouseleave = () => { moving[key] = false; };
}

setupButton('btn-forward',    'forward');
setupButton('btn-backward',   'backward');
setupButton('btn-left',       'left');
setupButton('btn-right',      'right');
setupButton('btn-curve-right','curveRight');
setupButton('btn-curve-left', 'curveLeft');

document.getElementById('btn-up').onclick   = () => { train.object3D.position.y += 0.1; };
document.getElementById('btn-down').onclick = () => { train.object3D.position.y -= 0.1; };

/* ========== é¡”å†™çœŸè²¼ã‚Šä»˜ã‘ ========== */
document.getElementById('btn-face').onclick = () => {
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = 'image/*';
  input.onchange = e => {
    const file = e.target.files[0];
    if (!file) return;
    const url = URL.createObjectURL(file);

    const applyToPlate = () => {
      new THREE.TextureLoader().load(url, tex => {
        tex.flipY = false;
        tex.encoding = THREE.sRGBEncoding;
        tex.needsUpdate = true;

        if (facePlate) {
          facePlate.material.map = tex;
          facePlate.material.needsUpdate = true;
          facePlate.rotation.y = faceRotationY;
          facePlate.rotation.x = faceRotationX;
        } else {
          const geo = new THREE.PlaneGeometry(1.0, 1.0);
          const mat = new THREE.MeshBasicMaterial({
            map: tex,
            transparent: true,
            side: THREE.DoubleSide,
            depthTest: false,
            depthWrite: false
          });
          const mesh = new THREE.Mesh(geo, mat);
          mesh.position.set(0.5, 2.8, -0.3);
          mesh.rotation.y = faceRotationY;
          mesh.rotation.x = faceRotationX;
          mesh.renderOrder = 10;
          train.object3D.add(mesh);
          facePlate = mesh;
        }
      });
    };

    if (train.getObject3D('mesh')) {
      applyToPlate();
    } else {
      train.addEventListener('model-loaded', applyToPlate, { once: true });
    }
  };
  input.click();
};

document.getElementById('btn-face-rotate-y').onclick = () => {
  if (facePlate) {
    faceRotationY += Math.PI / 2;
    facePlate.rotation.y = faceRotationY;
  }
};
document.getElementById('btn-face-rotate-x').onclick = () => {
  if (facePlate) {
    faceRotationX += Math.PI / 2;
    facePlate.rotation.x = faceRotationX;
  }
};

document.getElementById('btn-face-x-plus').onclick  = () => { if (facePlate) facePlate.position.x += 0.05; };
document.getElementById('btn-face-x-minus').onclick = () => { if (facePlate) facePlate.position.x -= 0.05; };
document.getElementById('btn-face-y-plus').onclick  = () => { if (facePlate) facePlate.position.y += 0.05; };
document.getElementById('btn-face-y-minus').onclick = () => { if (facePlate) facePlate.position.y -= 0.05; };

/* ========== ã‚ºãƒ¼ãƒ ï¼ˆåˆ—è»Šå…¨ä½“ã‚¹ã‚±ãƒ¼ãƒ«ï¼‰ ========== */
document.getElementById('btn-zoom-in').onclick = () => {
  zoomLevel += 0.1;
  train.object3D.scale.set(zoomLevel, zoomLevel, zoomLevel);
};
document.getElementById('btn-zoom-out').onclick = () => {
  zoomLevel = Math.max(0.1, zoomLevel - 0.1);
  train.object3D.scale.set(zoomLevel, zoomLevel, zoomLevel);
};

/* ========== ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆ ========== */
document.getElementById('btn-capture').onclick = () => {
  const canvas = document.querySelector('canvas');
  if (!canvas) return;
  canvas.toBlob(blob => {
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'snapshot.png';
    a.click();
  });
};

/* ========== éŒ²ç”» ========== */
document.getElementById('btn-record').onclick = () => {
  const canvas = document.querySelector('canvas');
  if (!canvas) return;

  if (!recording) {
    const stream = canvas.captureStream();
    recorder = new MediaRecorder(stream);
    recorder.ondataavailable = e => chunks.push(e.data);
    recorder.onstop = () => {
      const b = new Blob(chunks, { type: 'video/webm' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(b);
      a.download = 'recording.webm';
      a.click();
      chunks = [];
    };
    recorder.start();
    recording = true;
    alert('éŒ²ç”»é–‹å§‹');
  } else {
    recorder.stop();
    recording = false;
    alert('éŒ²ç”»çµ‚äº†');
  }
};

/* ========== å…±æœ‰ ========== */
document.getElementById('btn-share').onclick = () => {
  if (navigator.share) {
    navigator.share({
      title: 'AR Train',
      text: 'ç§ã®é‹è»¢å£«ä½“é¨“ã‚’è¦‹ã¦ã­ï¼',
      url: location.href
    });
  } else {
    alert('ã“ã®ãƒ–ãƒ©ã‚¦ã‚¶ã¯ Webã‚·ã‚§ã‚¢API ã«å¯¾å¿œã—ã¦ã„ã¾ã›ã‚“');
  }
};
</script>
</body>
</html>
