<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>Flower Liner AR Train</title>

  <!-- iPhone å…¨ç”»é¢ï¼†ã‚»ãƒ¼ãƒ•ã‚¨ãƒªã‚¢å¯¾å¿œ -->
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />

  <!-- A-Frame & AR.jsï¼ˆå®‰å®šç‰ˆï¼‰ -->
  <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js@3.4.4/aframe/build/aframe-ar.min.js"></script>

  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #000;
      touch-action: none;
      -webkit-user-select: none;
      user-select: none;
    }

    a-scene {
      position: fixed;
      inset: 0;
    }

    /* ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¡¨ç¤ºï¼ˆé»’ç”»é¢ãƒ‡ãƒãƒƒã‚°ç”¨ï¼‰ */
    #status {
      position: fixed;
      top: env(safe-area-inset-top, 0);
      left: 0;
      right: 0;
      padding: 4px 8px;
      font-size: 12px;
      color: #0f0;
      background: rgba(0, 0, 0, 0.5);
      z-index: 1000;
      white-space: pre-line;
      pointer-events: none;
    }

    /* UI ãƒœã‚¿ãƒ³ */
    #ui {
      position: fixed;
      bottom: env(safe-area-inset-bottom, 0);
      left: 0;
      right: 0;
      width: 100%;
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 4px;
      padding: 4px 0 10px;
      z-index: 999;
    }
    .btn {
      min-width: 64px;
      text-align: center;
      font-size: 14px;
      padding: 6px 10px;
      background: rgba(255, 255, 255, 0.9);
      border: 1px solid #333;
      border-radius: 4px;
      cursor: pointer;
      user-select: none;
    }
  </style>
</head>
<body>

<!-- ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¡¨ç¤º -->
<div id="status">åˆæœŸåŒ–ä¸­...</div>

<!-- AR.js ã‚·ãƒ¼ãƒ³ï¼šHiro ãƒãƒ¼ã‚«ãƒ¼ + é€šå¸¸ã‚«ãƒ¡ãƒ© -->
<a-scene
  embedded
  vr-mode-ui="enabled: false"
  renderer="antialias: true; alpha: true"
  arjs="trackingMethod: best; sourceType: webcam; debugUIEnabled: false; detectionMode: mono;">

  <!-- Hiro ãƒãƒ¼ã‚«ãƒ¼ä¸Šã«åˆ—è»Šã‚’é…ç½® -->
  <a-marker type="pattern" preset="hiro" id="hiroMarker">
    <a-entity id="train"
              gltf-model="models/AR-Train_Nagai.glb"
              position="0 0 0"
              rotation="0 0 0"
              scale="0.5 0.5 0.5">
    </a-entity>
  </a-marker>

  <!-- é€šå¸¸ã‚«ãƒ¡ãƒ© -->
  <a-entity camera></a-entity>
</a-scene>

<!-- ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ« UI -->
<div id="ui">
  <div class="btn" id="btn-forward">â†‘</div>
  <div class="btn" id="btn-backward">â†“</div>
  <div class="btn" id="btn-left">â†</div>
  <div class="btn" id="btn-right">â†’</div>
  <div class="btn" id="btn-curve-right">â†»å³ã‚«ãƒ¼ãƒ–</div>
  <div class="btn" id="btn-curve-left">â†ºå·¦ã‚«ãƒ¼ãƒ–</div>

  <div class="btn" id="btn-face">é¡”å†™çœŸè¨­å®š</div>
  <div class="btn" id="btn-face-rotate-y">é¡”YğŸ”„</div>
  <div class="btn" id="btn-face-rotate-x">é¡”XğŸ”„</div>
  <div class="btn" id="btn-face-x-plus">é¡”Xï¼‹</div>
  <div class="btn" id="btn-face-x-minus">é¡”Xï¼</div>
  <div class="btn" id="btn-face-y-plus">é¡”Yï¼‹</div>
  <div class="btn" id="btn-face-y-minus">é¡”Yï¼</div>

  <div class="btn" id="btn-zoom-in">ï¼‹</div>
  <div class="btn" id="btn-zoom-out">ï¼</div>
  <div class="btn" id="btn-capture">ğŸ“¸</div>
  <div class="btn" id="btn-record">ğŸ¥</div>
  <div class="btn" id="btn-share">ğŸ“¤</div>
</div>

<script>
  const statusEl = document.getElementById('status');
  function logStatus(msg) {
    console.log('[AR]', msg);
    statusEl.textContent = msg;
  }

  // ===== ã‚«ãƒ¡ãƒ©ç°¡æ˜“ãƒã‚§ãƒƒã‚¯ï¼ˆé»’ç”»é¢ãƒ‡ãƒãƒƒã‚°ç”¨ï¼‰ =====
  (function checkCamera() {
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
      logStatus('ã‚«ãƒ¡ãƒ©éå¯¾å¿œã®ãƒ–ãƒ©ã‚¦ã‚¶ã§ã™');
      return;
    }
    navigator.mediaDevices.getUserMedia({ video: true })
      .then(stream => {
        // ã™ãæ­¢ã‚ã‚‹ï¼ˆAR.jsç”¨ã«é–‹æ”¾ï¼‰
        stream.getTracks().forEach(t => t.stop());
        logStatus('ã‚«ãƒ¡ãƒ©å–å¾—OKã€‚Hiroãƒãƒ¼ã‚«ãƒ¼ã‚’æ˜ ã—ã¦ãã ã•ã„ã€‚');
      })
      .catch(err => {
        logStatus('ã‚«ãƒ¡ãƒ©å–å¾—ã‚¨ãƒ©ãƒ¼: ' + err.name + ' / ' + err.message);
      });
  })();

  // ===== åˆ—è»Šã¨é¡”å†™çœŸã¾ã‚ã‚Š =====
  const train = document.querySelector('#train');
  let facePlate = null;
  let faceRotationY = 0;
  let faceRotationX = 0;
  let zoomLevel = 0.5;

  let moving = { forward: false, backward: false, left: false, right: false };
  let curveRadius = 2.0;
  const MOVE_SPEED = 0.15;
  const ROTATE_SPEED = 1.0;

  let forwardAxis = 'z';
  const FORWARD_SIGN = 1;

  train.addEventListener('model-loaded', () => {
    logStatus('ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿å®Œäº†ã€‚Hiroãƒãƒ¼ã‚«ãƒ¼ã‚’æ˜ ã—ã¦ãã ã•ã„ã€‚');

    const root = train.getObject3D('mesh');
    if (!root) return;

    // a_Plate ã‚’æ¢ã™ï¼ˆé¡”å†™çœŸè²¼ã‚Šä»˜ã‘ç”¨ï¼‰
    facePlate = root.getObjectByName('a_Plate') || root.getObjectByProperty('name', 'a_Plate');

    // åˆ—è»Šã®é•·æ‰‹æ–¹å‘ã‚’æ¨å®š
    const box = new THREE.Box3().setFromObject(root);
    const sz = new THREE.Vector3();
    box.getSize(sz);
    forwardAxis = (sz.x > sz.z) ? 'x' : 'z';
  });

  // ===== å‰æ–¹ãƒ™ã‚¯ãƒˆãƒ« =====
  function getForwardWorld(obj) {
    const local = (forwardAxis === 'x')
      ? new THREE.Vector3(FORWARD_SIGN, 0, 0)
      : new THREE.Vector3(0, 0, FORWARD_SIGN);
    return local.applyQuaternion(obj.quaternion).normalize();
  }

  // ===== ç§»å‹•å‡¦ç† =====
  function moveTrain() {
    const obj = train.object3D;
    const pos = obj.position;

    const dir  = moving.forward ? 1 : (moving.backward ? -1 : 0);
    const turn = moving.left    ? 1 : (moving.right    ? -1 : 0);

    if (dir !== 0 && turn !== 0) {
      const v = dir * MOVE_SPEED;
      const omega = (turn * v) / curveRadius;
      obj.rotation.y += omega;
      pos.addScaledVector(getForwardWorld(obj), v);
    } else if (dir !== 0) {
      pos.addScaledVector(getForwardWorld(obj), dir * MOVE_SPEED);
    } else if (turn !== 0) {
      obj.rotation.y += turn * ROTATE_SPEED * Math.PI / 180;
    }

    if (Object.values(moving).some(v => v)) {
      requestAnimationFrame(moveTrain);
    }
  }

  // ===== ãƒœã‚¿ãƒ³ç™»éŒ² =====
  function setupMoveButton(btnId, key) {
    const btn = document.getElementById(btnId);
    if (!btn) return;

    const down = e => {
      moving[key] = true;
      moveTrain();
      e.preventDefault();
    };
    const up = () => { moving[key] = false; };

    btn.addEventListener('mousedown', down);
    btn.addEventListener('touchstart', down, { passive: false });
    btn.addEventListener('mouseup', up);
    btn.addEventListener('touchend', up);
    btn.addEventListener('mouseleave', up);
  }

  setupMoveButton('btn-forward',  'forward');
  setupMoveButton('btn-backward', 'backward');
  setupMoveButton('btn-left',     'left');
  setupMoveButton('btn-right',    'right');

  // ã‚«ãƒ¼ãƒ–ãƒœã‚¿ãƒ³ã¯ã€Œå‰é€²ï¼‹å›è»¢ã€ã‚’ä¸€åº¦ã«
  document.getElementById('btn-curve-right').onclick = () => {
    moving.forward = true;
    moving.right   = true;
    moveTrain();
    setTimeout(() => { moving.forward = moving.right = false; }, 500);
  };
  document.getElementById('btn-curve-left').onclick = () => {
    moving.forward = true;
    moving.left    = true;
    moveTrain();
    setTimeout(() => { moving.forward = moving.left = false; }, 500);
  };

  // ===== é¡”å†™çœŸè¨­å®š =====
  document.getElementById('btn-face').onclick = () => {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = 'image/*';
    input.onchange = e => {
      const file = e.target.files[0];
      if (!file) return;
      const url = URL.createObjectURL(file);

      const applyToPlate = () => {
        new THREE.TextureLoader().load(url, tex => {
          tex.flipY = false;
          tex.encoding = THREE.sRGBEncoding;
          tex.needsUpdate = true;

          if (facePlate) {
            facePlate.material.map = tex;
            facePlate.material.needsUpdate = true;
            facePlate.rotation.y = faceRotationY;
            facePlate.rotation.x = faceRotationX;
          } else {
            const geo = new THREE.PlaneGeometry(1.0, 1.0);
            const mat = new THREE.MeshBasicMaterial({
              map: tex,
              transparent: true,
              side: THREE.DoubleSide,
              depthTest: false,
              depthWrite: false
            });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(0.5, 2.8, -0.3);
            mesh.rotation.y = faceRotationY;
            mesh.rotation.x = faceRotationX;
            mesh.renderOrder = 10;
            train.object3D.add(mesh);
            facePlate = mesh;
          }
        });
      };

      if (train.getObject3D('mesh')) {
        applyToPlate();
      } else {
        train.addEventListener('model-loaded', applyToPlate, { once: true });
      }
    };
    input.click();
  };

  document.getElementById('btn-face-rotate-y').onclick = () => {
    if (facePlate) {
      faceRotationY += Math.PI / 2;
      facePlate.rotation.y = faceRotationY;
    }
  };
  document.getElementById('btn-face-rotate-x').onclick = () => {
    if (facePlate) {
      faceRotationX += Math.PI / 2;
      facePlate.rotation.x = faceRotationX;
    }
  };

  document.getElementById('btn-face-x-plus').onclick  = () => { if (facePlate) facePlate.position.x += 0.05; };
  document.getElementById('btn-face-x-minus').onclick = () => { if (facePlate) facePlate.position.x -= 0.05; };
  document.getElementById('btn-face-y-plus').onclick  = () => { if (facePlate) facePlate.position.y += 0.05; };
  document.getElementById('btn-face-y-minus').onclick = () => { if (facePlate) facePlate.position.y -= 0.05; };

  // ===== ã‚ºãƒ¼ãƒ  =====
  document.getElementById('btn-zoom-in').onclick = () => {
    zoomLevel += 0.1;
    train.object3D.scale.set(zoomLevel, zoomLevel, zoomLevel);
  };
  document.getElementById('btn-zoom-out').onclick = () => {
    zoomLevel = Math.max(0.1, zoomLevel - 0.1);
    train.object3D.scale.set(zoomLevel, zoomLevel, zoomLevel);
  };

  // ===== ã‚­ãƒ£ãƒ—ãƒãƒ£ãƒ»éŒ²ç”»ãƒ»ã‚·ã‚§ã‚¢ =====
  document.getElementById('btn-capture').onclick = () => {
    const canvas = document.querySelector('canvas');
    if (!canvas) return;
    canvas.toBlob(blob => {
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = "snapshot.png";
      a.click();
    });
  };

  let recording = false;
  let recorder = null;
  let chunks = [];

  document.getElementById('btn-record').onclick = () => {
    const canvas = document.querySelector('canvas');
    if (!canvas) return;

    if (!recording) {
      const stream = canvas.captureStream();
      recorder = new MediaRecorder(stream);
      recorder.ondataavailable = e => chunks.push(e.data);
      recorder.onstop = () => {
        const b = new Blob(chunks, { type: 'video/webm' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(b);
        a.download = "recording.webm";
        a.click();
        chunks = [];
      };
      recorder.start();
      recording = true;
      alert("éŒ²ç”»é–‹å§‹");
    } else {
      recorder.stop();
      recording = false;
      alert("éŒ²ç”»çµ‚äº†");
    }
  };

  document.getElementById('btn-share').onclick = () => {
    if (navigator.share) {
      navigator.share({
        title: "AR Train",
        text: "ç§ã®é‹è»¢å£«ä½“é¨“ã‚’è¦‹ã¦ã­ï¼",
        url: location.href
      });
    } else {
      alert("ã“ã®ãƒ–ãƒ©ã‚¦ã‚¶ã¯Webã‚·ã‚§ã‚¢APIã«å¯¾å¿œã—ã¦ã„ã¾ã›ã‚“");
    }
  };
</script>
</body>
</html>
