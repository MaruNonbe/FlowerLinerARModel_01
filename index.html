<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>Marker AR Train</title>

  <!-- A-Frame & AR.js -->
  <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js/aframe/build/aframe-ar.js"></script>

  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #000;
      touch-action: none;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
    }

    a-scene {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    #ui {
      position: fixed;
      bottom: 10px;
      width: 100%;
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 5px;
      z-index: 999;
      pointer-events: auto;
    }

    .btn {
      min-width: 60px;
      text-align: center;
      font-size: 14px;
      padding: 6px 10px;
      background: rgba(255, 255, 255, 0.9);
      border: 1px solid #333;
      border-radius: 4px;
      cursor: pointer;
      user-select: none;
    }
  </style>
</head>
<body>

<!-- â˜… ãƒãƒ¼ã‚«ãƒ¼ã€Œhiroã€ç”¨ã®ARã‚·ãƒ¼ãƒ³ï¼ˆWebã‚«ãƒ¡ãƒ©ã‚½ãƒ¼ã‚¹ï¼‰ -->
<a-scene
    embedded
    vr-mode-ui="enabled: false"
    renderer="logarithmicDepthBuffer: true; alpha: true; antialias: true;"
    arjs="trackingMethod: best; sourceType: webcam; debugUIEnabled: false">

  <!-- ãƒãƒ¼ã‚«ãƒ¼ã«åŒæœŸã™ã‚‹ã‚«ãƒ¡ãƒ© -->
  <a-marker-camera preset="hiro">
    <!-- åˆ—è»Šãƒ¢ãƒ‡ãƒ«ï¼šãƒãƒ¼ã‚«ãƒ¼ã‹ã‚‰2må‰æ–¹ãƒ»å°‘ã—å°ã•ã‚ -->
    <a-entity id="train"
              gltf-model="url(models/AR-Train_Nagai.glb)"
              position="0 0 -2"
              rotation="0 0 0"
              scale="0.3 0.3 0.3">
    </a-entity>
  </a-marker-camera>

</a-scene>

<!-- UIãƒœã‚¿ãƒ³ç¾¤ -->
<div id="ui">
  <div class="btn" id="btn-forward">â†‘</div>
  <div class="btn" id="btn-backward">â†“</div>
  <div class="btn" id="btn-left">â†</div>
  <div class="btn" id="btn-right">â†’</div>

  <div class="btn" id="btn-curve-right">â†ªå³ã‚«ãƒ¼ãƒ–</div>
  <div class="btn" id="btn-curve-left">â†©å·¦ã‚«ãƒ¼ãƒ–</div>

  <div class="btn" id="btn-up">â¬†ï¸</div>
  <div class="btn" id="btn-down">â¬‡ï¸</div>

  <div class="btn" id="btn-face">é¡”å†™çœŸè¨­å®š</div>
  <div class="btn" id="btn-face-rotate-y">é¡”YğŸ”„</div>
  <div class="btn" id="btn-face-rotate-x">é¡”XğŸ”„</div>
  <div class="btn" id="btn-face-x-plus">é¡”Xï¼‹</div>
  <div class="btn" id="btn-face-x-minus">é¡”Xï¼</div>
  <div class="btn" id="btn-face-y-plus">é¡”Yï¼‹</div>
  <div class="btn" id="btn-face-y-minus">é¡”Yï¼</div>

  <div class="btn" id="btn-zoom-in">ï¼‹</div>
  <div class="btn" id="btn-zoom-out">ï¼</div>

  <div class="btn" id="btn-capture">ğŸ“¸</div>
  <div class="btn" id="btn-record">ğŸ¥</div>
  <div class="btn" id="btn-share">ğŸ“¤</div>
</div>

<script>
  const train = document.querySelector('#train');

  // ======== çŠ¶æ…‹å¤‰æ•° ========
  let facePlate = null;     // a_Plate ãƒ¡ãƒƒã‚·ãƒ¥
  let forwardAxis = 'z';    // åˆ—è»Šã®é•·æ‰‹æ–¹å‘ï¼ˆx or zï¼‰
  const FORWARD_SIGN = 1;
  const MOVE_SPEED = 0.15;
  const ROTATE_SPEED = 1.0 * Math.PI / 180; // rad
  const CURVE_RADIUS = 2.0;

  let moving = { forward: false, backward: false, left: false, right: false };
  let curve = { right: false, left: false };

  let zoomLevel = 0.3;
  let recording = false, recorder, chunks = [];
  let faceRotationY = 0;
  let faceRotationX = 0;

  // ======== ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿å¾Œã®å‡¦ç† ========
  train.addEventListener('model-loaded', () => {
    const root = train.getObject3D('mesh');
    if (!root) return;

    // a_Plate ã‚’æ¢ã™ï¼ˆé‹è»¢å¸­ã®æ¿ï¼‰
    facePlate =
      root.getObjectByName('a_Plate') ||
      root.getObjectByProperty('name', 'a_Plate') ||
      null;

    // é•·æ‰‹æ–¹å‘ã‚’æ¨å®šï¼ˆXã¨Zã©ã¡ã‚‰ãŒé•·ã„ã‹ï¼‰
    const box = new THREE.Box3().setFromObject(root);
    const sz = new THREE.Vector3();
    box.getSize(sz);
    forwardAxis = (sz.x > sz.z) ? 'x' : 'z';
  });

  // ======== é€²è¡Œæ–¹å‘ãƒ™ã‚¯ãƒˆãƒ« ========
  function getForwardWorld(obj) {
    const local = (forwardAxis === 'x')
      ? new THREE.Vector3(FORWARD_SIGN, 0, 0)
      : new THREE.Vector3(0, 0, FORWARD_SIGN);
    return local.applyQuaternion(obj.quaternion).normalize();
  }

  // ======== ç§»å‹•å‡¦ç† ========
  function moveTrain() {
    const obj = train.object3D;
    const pos = obj.position;

    const dir  = moving.forward ? 1 : (moving.backward ? -1 : 0);
    const turn = moving.left ? 1 : (moving.right ? -1 : 0);

    // ã‚«ãƒ¼ãƒ–ï¼ˆãƒœã‚¿ãƒ³å°‚ç”¨ï¼‰ã‚’å„ªå…ˆ
    const curveDir = curve.right ? -1 : (curve.left ? 1 : 0);

    if (dir !== 0 || turn !== 0 || curveDir !== 0) {
      const forward = getForwardWorld(obj);

      if (curveDir !== 0 && dir !== 0) {
        // é€²è¡Œæ–¹å‘ï¼‹ã‚«ãƒ¼ãƒ–
        const v = dir * MOVE_SPEED;
        const omega = (curveDir * v) / CURVE_RADIUS; // rad
        obj.rotation.y += omega;
        pos.addScaledVector(forward, v);
      } else {
        if (dir !== 0) {
          pos.addScaledVector(forward, dir * MOVE_SPEED);
        }
        if (turn !== 0) {
          obj.rotation.y += turn * ROTATE_SPEED;
        }
      }
      requestAnimationFrame(moveTrain);
    }
  }

  // ======== ãƒœã‚¿ãƒ³è¨­å®š ========
  function setupButtonHold(id, key) {
    const btn = document.getElementById(id);
    const start = (e) => {
      moving[key] = true;
      moveTrain();
      e.preventDefault();
    };
    const end = (e) => {
      moving[key] = false;
      e && e.preventDefault();
    };
    btn.addEventListener('mousedown', start);
    btn.addEventListener('touchstart', start, { passive: false });
    btn.addEventListener('mouseup', end);
    btn.addEventListener('mouseleave', end);
    btn.addEventListener('touchend', end);
    btn.addEventListener('touchcancel', end);
  }

  setupButtonHold('btn-forward',  'forward');
  setupButtonHold('btn-backward', 'backward');
  setupButtonHold('btn-left',     'left');
  setupButtonHold('btn-right',    'right');

  // ã‚«ãƒ¼ãƒ–ã¯æŠ¼ã—ã¦ã„ã‚‹é–“ã ã‘æœ‰åŠ¹
  function setupCurveButton(id, dirKey) {
    const btn = document.getElementById(id);
    const start = (e) => {
      curve[dirKey] = true;
      moveTrain();
      e.preventDefault();
    };
    const end = (e) => {
      curve[dirKey] = false;
      e && e.preventDefault();
    };
    btn.addEventListener('mousedown', start);
    btn.addEventListener('touchstart', start, { passive: false });
    btn.addEventListener('mouseup', end);
    btn.addEventListener('mouseleave', end);
    btn.addEventListener('touchend', end);
    btn.addEventListener('touchcancel', end);
  }

  setupCurveButton('btn-curve-right', 'right');
  setupCurveButton('btn-curve-left',  'left');

  // ä¸Šä¸‹ç§»å‹•
  document.getElementById('btn-up').onclick   = () => { train.object3D.position.y += 0.1; };
  document.getElementById('btn-down').onclick = () => { train.object3D.position.y -= 0.1; };

  // ======== é¡”å†™çœŸè¨­å®š ========
  document.getElementById('btn-face').onclick = () => {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = 'image/*';
    input.onchange = e => {
      const file = e.target.files[0];
      if (!file) return;
      const url = URL.createObjectURL(file);

      const applyToPlate = () => {
        const loader = new THREE.TextureLoader();
        loader.load(url, tex => {
          tex.flipY = false;
          tex.encoding = THREE.sRGBEncoding;
          tex.needsUpdate = true;

          if (facePlate) {
            facePlate.material.map = tex;
            facePlate.material.transparent = true;
            facePlate.material.needsUpdate = true;
          } else {
            const geo = new THREE.PlaneGeometry(0.6, 0.6);
            const mat = new THREE.MeshBasicMaterial({
              map: tex,
              transparent: true,
              side: THREE.DoubleSide,
              depthTest: false,
              depthWrite: false
            });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(0, 0.5, 0.8);
            mesh.renderOrder = 10;
            train.object3D.add(mesh);
            facePlate = mesh;
          }

          facePlate.rotation.y = faceRotationY;
          facePlate.rotation.x = faceRotationX;
        });
      };

      if (train.getObject3D('mesh')) {
        applyToPlate();
      } else {
        train.addEventListener('model-loaded', applyToPlate, { once: true });
      }
    };
    input.click();
  };

  document.getElementById('btn-face-rotate-y').onclick = () => {
    if (!facePlate) return;
    faceRotationY += Math.PI / 2;
    facePlate.rotation.y = faceRotationY;
  };
  document.getElementById('btn-face-rotate-x').onclick = () => {
    if (!facePlate) return;
    faceRotationX += Math.PI / 2;
    facePlate.rotation.x = faceRotationX;
  };

  document.getElementById('btn-face-x-plus').onclick  = () => { if (facePlate) facePlate.position.x += 0.05; };
  document.getElementById('btn-face-x-minus').onclick = () => { if (facePlate) facePlate.position.x -= 0.05; };
  document.getElementById('btn-face-y-plus').onclick  = () => { if (facePlate) facePlate.position.y += 0.05; };
  document.getElementById('btn-face-y-minus').onclick = () => { if (facePlate) facePlate.position.y -= 0.05; };

  // ======== ã‚ºãƒ¼ãƒ ï¼ˆã‚¹ã‚±ãƒ¼ãƒ«ï¼‰ ========
  document.getElementById('btn-zoom-in').onclick = () => {
    zoomLevel += 0.05;
    train.object3D.scale.set(zoomLevel, zoomLevel, zoomLevel);
  };
  document.getElementById('btn-zoom-out').onclick = () => {
    zoomLevel = Math.max(0.1, zoomLevel - 0.05);
    train.object3D.scale.set(zoomLevel, zoomLevel, zoomLevel);
  };

  // ======== å†™çœŸæ’®å½±ãƒ»éŒ²ç”»ãƒ»ã‚·ã‚§ã‚¢ ========
  document.getElementById('btn-capture').onclick = () => {
    const canvas = document.querySelector('canvas');
    if (!canvas) return;
    canvas.toBlob(blob => {
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'snapshot.png';
      a.click();
    });
  };

  document.getElementById('btn-record').onclick = () => {
    const canvas = document.querySelector('canvas');
    if (!canvas) return;

    if (!recording) {
      const stream = canvas.captureStream();
      recorder = new MediaRecorder(stream);
      recorder.ondataavailable = e => chunks.push(e.data);
      recorder.onstop = () => {
        const blob = new Blob(chunks, { type: 'video/webm' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = 'recording.webm';
        a.click();
        chunks = [];
      };
      recorder.start();
      recording = true;
      alert('éŒ²ç”»é–‹å§‹');
    } else {
      recorder.stop();
      recording = false;
      alert('éŒ²ç”»çµ‚äº†');
    }
  };

  document.getElementById('btn-share').onclick = () => {
    if (navigator.share) {
      navigator.share({
        title: 'AR Train',
        text: 'ARã§åˆ—è»Šã‚’é‹è»¢ã—ã¦ã¿ã¾ã—ãŸï¼',
        url: location.href
      });
    } else {
      alert('ã“ã®ãƒ–ãƒ©ã‚¦ã‚¶ã¯Webã‚·ã‚§ã‚¢APIã«å¯¾å¿œã—ã¦ã„ã¾ã›ã‚“');
    }
  };
</script>

</body>
</html>
