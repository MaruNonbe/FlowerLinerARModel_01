<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>AR Train WebAR</title>

  <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.150.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js/aframe/build/aframe-ar.js"></script>

  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      height: 100%;
      background-color: transparent; /* 重要：ここを透明にしないと背景が見えないことがある */
    }

    /* A-Frameシーンの設定 */
    a-scene {
      position: fixed !important;
      top: 0;
      left: 0;
      width: 100% !important;
      height: 100% !important;
      z-index: 1;
    }

    /* UI ボタン群 */
    #ui {
      position: fixed;
      bottom: 20px;
      left: 0;
      width: 100%;
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 8px;
      z-index: 9999;
      pointer-events: none; /* ボタン以外へのタッチをスルーさせる */
    }
    .btn {
      pointer-events: auto; /* ボタン自体はタッチ可能 */
      min-width: 60px;
      text-align: center;
      font-size: 14px;
      font-weight: bold;
      padding: 10px 6px;
      background: rgba(255, 255, 255, 0.8);
      border: 1px solid #333;
      border-radius: 8px;
      cursor: pointer;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation; /* ダブルタップズーム等を無効化 */
    }
    .btn:active {
      background: rgba(200, 200, 200, 0.9);
    }

    /* 状態メッセージ */
    #status {
      position: fixed;
      top: 10px;
      left: 10px;
      right: 10px;
      padding: 6px;
      font-size: 14px;
      text-align: center;
      color: #0f0;
      background: rgba(0, 0, 0, 0.6);
      border-radius: 4px;
      z-index: 9999;
      pointer-events: none;
    }
  </style>
</head>
<body>

<div id="status">カメラ起動中... マーカーを用意してください</div>

<a-scene
  vr-mode-ui="enabled: false"
  embedded
  renderer="precision: mediump; antialias: true; alpha: true;"
  arjs="trackingMethod: best; sourceType: webcam; debugUIEnabled: false;"
>
  <a-marker-camera preset="hiro">
    <a-entity id="train"
              gltf-model="models/AR-Train_Nagai.glb"
              position="0 0 -1"
              rotation="0 0 0"
              scale="0.5 0.5 0.5">
    </a-entity>
  </a-marker-camera>
</a-scene>

<div id="ui">
  <div class="btn" id="btn-forward">前進</div>
  <div class="btn" id="btn-backward">後進</div>
  
  <div class="btn" id="btn-left">その場左</div>
  <div class="btn" id="btn-right">その場右</div>
  <div class="btn" id="btn-curve-left">左カーブ</div>
  <div class="btn" id="btn-curve-right">右カーブ</div>

  <div class="btn" id="btn-up">上へ</div>
  <div class="btn" id="btn-down">下へ</div>

  <div class="btn" id="btn-face">顔写真</div>
  <div class="btn" id="btn-face-rotate-y">顔回転Y</div>
  <div class="btn" id="btn-face-rotate-x">顔回転X</div>
  <div class="btn" id="btn-face-x-plus">顔X+</div>
  <div class="btn" id="btn-face-x-minus">顔X-</div>
  <div class="btn" id="btn-face-y-plus">顔Y+</div>
  <div class="btn" id="btn-face-y-minus">顔Y-</div>

  <div class="btn" id="btn-zoom-in">拡大</div>
  <div class="btn" id="btn-zoom-out">縮小</div>
  <div class="btn" id="btn-capture">撮影</div>
  <div class="btn" id="btn-record">録画</div>
  <div class="btn" id="btn-share">共有</div>
</div>

<script>
/* ========== 初期設定 ========== */
const statusEl    = document.getElementById('status');
const train       = document.querySelector('#train');
let   facePlate   = null;
let   forwardAxis = 'z'; // 自動判定で上書きされます
const FORWARD_SIGN = 1;

// ★カーブ設定（半径を小さくして、室内で曲がりやすく調整）
let curveRadius = 0.6; // メートル
const MOVE_SPEED   = 0.05; // 少しゆっくりに（制御しやすくするため）
const ROTATE_SPEED = 1.0;  // その場回転の速さ

// 状態フラグ
let moving = {
  forward: false,
  backward: false,
  left: false,
  right: false,
  curveRight: false,
  curveLeft: false
};

let zoomLevel = 0.5;
let recording = false, recorder, chunks = [];
let faceRotationY = 0;
let faceRotationX = 0;

/* ========== モデル読み込み完了時の処理 ========== */
train.addEventListener('model-loaded', () => {
  const root = train.getObject3D('mesh');
  if (!root) return;

  // 顔写真用プレートを探す
  facePlate = root.getObjectByName('a_Plate') ||
              root.getObjectByProperty('name', 'a_Plate');

  // モデルの向き（長手方向）を判定
  const box = new THREE.Box3().setFromObject(root);
  const size = new THREE.Vector3();
  box.getSize(size);
  forwardAxis = (size.x > size.z) ? 'x' : 'z';

  // 初期位置のリセット
  const obj = train.object3D;
  obj.position.set(0, 0, -2);
  obj.rotation.set(0, 0, 0);

  statusEl.textContent = 'Hiroマーカーを映してください';
});

/* ========== 進行方向ベクトル計算 ========== */
function getForwardWorld(obj) {
  const local = (forwardAxis === 'x')
    ? new THREE.Vector3(FORWARD_SIGN, 0, 0)
    : new THREE.Vector3(0, 0, FORWARD_SIGN);
  return local.applyQuaternion(obj.quaternion).normalize();
}

/* ========== 移動ループ（毎フレーム実行） ========== */
function moveTrain() {
  const obj = train.object3D;
  const pos = obj.position;

  // 入力状態の整理
  const isMovingForward  = moving.forward;
  const isMovingBackward = moving.backward;
  const isTurningLeft    = moving.left;
  const isTurningRight   = moving.right;
  const isCurvingLeft    = moving.curveLeft;
  const isCurvingRight   = moving.curveRight;

  // 進行方向 (1:前, -1:後, 0:停止)
  const dir = isMovingForward ? 1 : (isMovingBackward ? -1 : 0);

  // カーブ処理 (前進または後進中のみ有効)
  if (dir !== 0 && (isCurvingLeft || isCurvingRight)) {
    const v = dir * MOVE_SPEED;
    // 右カーブなら -1, 左カーブなら 1
    // (後進時も見たままの方向に曲がるよう単純化しています)
    const turnSign = isCurvingRight ? -1 : 1;
    
    // 角速度 ω = v / r
    const omega = (turnSign * v) / curveRadius;
    
    obj.rotation.y += omega; // 回転
    pos.addScaledVector(getForwardWorld(obj), v); // 前進
  }
  // 直進のみ
  else if (dir !== 0) {
    pos.addScaledVector(getForwardWorld(obj), dir * MOVE_SPEED);
  }
  // その場回転のみ
  else if (isTurningLeft || isTurningRight) {
    const turnDir = isTurningLeft ? 1 : -1;
    obj.rotation.y += turnDir * ROTATE_SPEED * (Math.PI / 180);
  }

  // いずれかのボタンが押されていればループ継続
  if (Object.values(moving).some(v => v)) {
    requestAnimationFrame(moveTrain);
  }
}

/* ========== ボタンイベント登録 ========== */
function setupButton(id, key) {
  const btn = document.getElementById(id);
  if (!btn) return;

  const start = (e) => {
    // スマホでの長押し選択やスクロールを防ぐ
    if (e.cancelable) e.preventDefault();
    moving[key] = true;
    moveTrain();
  };
  
  const end = (e) => {
    if (e.cancelable) e.preventDefault();
    moving[key] = false;
  };

  // タッチイベント (スマホ用)
  btn.addEventListener('touchstart', start, { passive: false });
  btn.addEventListener('touchend', end);
  
  // マウスイベント (PC用)
  btn.addEventListener('mousedown', start);
  btn.addEventListener('mouseup', end);
  btn.addEventListener('mouseleave', end);
}

// ボタンIDとフラグの紐付け
setupButton('btn-forward',    'forward');
setupButton('btn-backward',   'backward');
setupButton('btn-left',       'left');
setupButton('btn-right',      'right');
setupButton('btn-curve-left', 'curveLeft');
setupButton('btn-curve-right','curveRight');

/* ========== その他機能ボタン ========== */
document.getElementById('btn-up').onclick    = () => { train.object3D.position.y += 0.1; };
document.getElementById('btn-down').onclick = () => { train.object3D.position.y -= 0.1; };

// ズーム
document.getElementById('btn-zoom-in').onclick = () => {
  zoomLevel += 0.1;
  train.object3D.scale.set(zoomLevel, zoomLevel, zoomLevel);
};
document.getElementById('btn-zoom-out').onclick = () => {
  zoomLevel = Math.max(0.1, zoomLevel - 0.1);
  train.object3D.scale.set(zoomLevel, zoomLevel, zoomLevel);
};

// 顔写真設定
document.getElementById('btn-face').onclick = () => {
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = 'image/*';
  input.onchange = e => {
    const file = e.target.files[0];
    if (!file) return;
    const url = URL.createObjectURL(file);

    const applyToPlate = () => {
      new THREE.TextureLoader().load(url, tex => {
        tex.flipY = false;
        tex.encoding = THREE.sRGBEncoding;
        
        if (facePlate) {
          facePlate.material.map = tex;
          facePlate.material.needsUpdate = true;
        } else {
          // プレートがない場合の予備作成
          const geo = new THREE.PlaneGeometry(1, 1);
          const mat = new THREE.MeshBasicMaterial({
            map: tex, transparent: true, side: THREE.DoubleSide
          });
          const mesh = new THREE.Mesh(geo, mat);
          mesh.position.set(0.5, 2.8, -0.3); // 仮の位置
          train.object3D.add(mesh);
          facePlate = mesh;
        }
      });
    };
    if (train.getObject3D('mesh')) applyToPlate();
    else train.addEventListener('model-loaded', applyToPlate, { once: true });
  };
  input.click();
};

// 顔位置・回転調整
document.getElementById('btn-face-rotate-y').onclick = () => { if (facePlate) facePlate.rotation.y += Math.PI/2; };
document.getElementById('btn-face-rotate-x').onclick = () => { if (facePlate) facePlate.rotation.x += Math.PI/2; };
document.getElementById('btn-face-x-plus').onclick = () => { if (facePlate) facePlate.position.x += 0.05; };
document.getElementById('btn-face-x-minus').onclick = () => { if (facePlate) facePlate.position.x -= 0.05; };
document.getElementById('btn-face-y-plus').onclick = () => { if (facePlate) facePlate.position.y += 0.05; };
document.getElementById('btn-face-y-minus').onclick = () => { if (facePlate) facePlate.position.y -= 0.05; };

// 撮影
document.getElementById('btn-capture').onclick = () => {
  const canvas = document.querySelector('canvas');
  canvas.toBlob(blob => {
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = 'ar-train-snap.png';
    link.click();
  });
};

// 録画
document.getElementById('btn-record').onclick = () => {
  const canvas = document.querySelector('canvas');
  if (!recording) {
    const stream = canvas.captureStream(30);
    recorder = new MediaRecorder(stream, { mimeType: 'video/webm' });
    recorder.ondataavailable = e => { if(e.data.size > 0) chunks.push(e.data); };
    recorder.onstop = () => {
      const blob = new Blob(chunks, { type: 'video/webm' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'ar-train-movie.webm';
      a.click();
      chunks = [];
    };
    recorder.start();
    recording = true;
    alert('録画開始');
  } else {
    recorder.stop();
    recording = false;
    alert('録画終了');
  }
};

// 共有
document.getElementById('btn-share').onclick = () => {
  if (navigator.share) {
    navigator.share({
      title: 'AR Train',
      text: 'ARで列車を運転中！',
      url: location.href
    }).catch(console.error);
  } else {
    alert('このブラウザは共有機能に対応していません');
  }
};

/* ========== ★縦横比歪み対策（追加） ========== */
window.addEventListener('resize', () => {
  const scene = document.querySelector('a-scene');
  const camera = scene.camera;
  if (camera) {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
  }
});
</script>
</body>
</html>